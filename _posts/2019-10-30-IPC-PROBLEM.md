---
layout: post
title: 'IPC PROBLEM'
date: 2019-10-30
author: downeyking
cover: 'https://i.loli.net/2019/12/31/BHa7FuelxwUsKIb.jpg'    
tags: OS
---

> Analysis to inter-process communication.  

提出问题：

1. 一个进程如何把信息传给另一个进程？

2. 如何确保两个进程再关键活动中不会出现交叉？

3. 如何让进程保持正确的顺序？

   

提出概念：

​		*竞争条件* ：两个或多个进程读写某些共享数据，最后的结果取决于进程运行的精确时序。

​		*临界区* ：对共享内存进行访问的程序片段。

​		*互斥* ：用某种手段确保一个进程在使用一个共享变量或文件时其他进程不能做同样的操作。



问题本质：确保在某一时刻只有一个进程可以对临界区进行访问，即实现进程的互斥。



解决方案：

1. 屏蔽中断

   在每个进程刚刚进去临界区后立刻屏蔽所有中断，并在离开之前再打开所有中断。

   缺点:

   - 一个进程中断后不再打开中断会使整个系统无法继续运行。

   - 多核芯片机制使得屏蔽并不真正有效。

     

2. 锁变量

   设有个共享锁变量，初始值为0。任何进程进入临界区前都要测试锁变量。锁为0，进程将锁设为1并进入临界区。锁为1，则进程不断等待直到锁变为0。于是，0代表临界区内无进程，1待变临界区内已经有进程。

   缺点：

   - 在一个进程发现锁为0且刚好在它设置锁为1之前，有另一个进程调度并将锁设为1，这样子临界区内还是拥有两个进程。

     

3. 严格轮换法

   设置turn变量，初始值为0，用于记录轮到哪个进程进入临界区。开始时turn为0，进程0进入，进程1等待。直到进程0结束工作退出临界区并把turn设置为1，进程1便可以进入临界区。

   <img src="https://i.loli.net/2019/10/30/bedBrXJNDHAnktm.png" alt="1.png" style="zoom: 33%;" />

   缺点：
   
   - 在一个进程比另一个进程慢很多时，这种工作方式会使得工作效率降低。
   
   


4. Peterson解法

   *是一种非谦让算法，即谁先调用 enter，谁就先进入临界区；将锁变量和警告变量结合*

   一个进程0准备进入临界区时，必须先把turn轮到自己，把interested设为true。

   当进程1不想进入临界区时，enter_region很快返回，进程0成功进入临界区。

   当进程1也想进入临界区即调用enter_region时，它被挂起直到进程0执行工作完毕，interested设置为0时才能成功进入。

   <img src="https://i.loli.net/2019/10/30/YcHQ9xsw7zmC8yF.png" alt="2.png" style="zoom: 50%;" />

   缺点：

   - 忙等待时间浪费太多，CPU利用率低。
   - 考虑两个进程H,L 。H优先级高，L优先级低。在某一时刻L处于临界区，H变为就绪态准备运行。H开始忙等待，但由于H优先级高，就绪时L不会被调度，无法离开临界区，H便一直忙等待下去，这种情况称之为优先级反转问题。



生产者-消费者问题：

- 唤醒操作wakeup


- 睡眠操作sleep


![3.png](https://i.loli.net/2019/10/30/O5PWhu8lAcgQrKX.png)

信号量：

​		用一个整型变量累计唤醒次数，以供使用。

​		一个信号量的取值可以为0（表示没有保存下来的唤醒操作）

​		也可以为正值（表示有一个或多个唤醒操作）

> Dijkstra建议设置两种操作：down（P）和up（V）。down操作表示用掉一个唤醒信号。up操作表示升起一个唤醒信号。P，V操作都是不可分割的，即在该操作完成或阻塞前，其他进程不允许访问此信号量。



用信号量解决生产者-消费者问题

![4.png](https://i.loli.net/2019/10/30/BCSOcPtkGxzwQYW.png)